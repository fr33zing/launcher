repositories { mavenCentral() }

dependencies { implementation(gradleApi()) }

plugins { `kotlin-dsl` }

tasks {
    register("generate") {
        val thisFile = "buildSrc/build.gradle.kts"
        val domain = "com.example.mylauncher"
        val dir = "../app/src/main/java/${domain.replace(".", "/")}/data/persistent"
        val fileName = "Generated.kt"
        val packageName = "$domain.data.persistent"
        val databaseVersion = "1"
        val payloadClasses = listOf("Node", "Application")
        val nodeKindToPayloadClassMap =
            mapOf(
                // NodeKind         Payload
                "Application" to "Application",
            )
        val textParts =
            listOf(
                headerComment(thisFile),
                "package $packageName",
                imports(domain),
                database(databaseVersion, payloadClasses, nodeKindToPayloadClassMap),
                allPayloadDaos(payloadClasses),
            )
        val text = textParts.joinToString("\n\n")

        val f = file("$dir/$fileName")
        f.createNewFile()
        f.writeText(text)
    }
    named("compileKotlin") { dependsOn("generate") }
}

fun headerComment(thisFile: String) =
    """
    // This file is automatically generated, don't edit it!
    // Generator: $thisFile
    """
        .trimIndent()

fun imports(domain: String) =
    """
    import androidx.room.Dao
    import androidx.room.Database
    import androidx.room.Delete
    import androidx.room.Insert
    import androidx.room.Query
    import androidx.room.RoomDatabase
    import androidx.room.Transaction
    import androidx.room.Update
    import $domain.data.NodeKind
    """
        .trimIndent()

fun payloadDao(payloadClass: String) =
    """
    @Dao
    interface ${payloadClass}Dao {
        @Insert suspend fun insert(entity: $payloadClass)

        @Transaction @Insert suspend fun insertMany(entities: List<$payloadClass>)

        @Update suspend fun update(entity: $payloadClass)

        @Transaction @Update suspend fun updateMany(entities: List<$payloadClass>)

        @Delete suspend fun delete(entity: $payloadClass)

        @Transaction @Delete suspend fun deleteMany(entities: List<$payloadClass>)

        @Query("SELECT * FROM $payloadClass") suspend fun getAllPayloads(): List<$payloadClass>

        @Query("SELECT * FROM $payloadClass WHERE nodeId = :nodeId")
        suspend fun getPayloadByNodeId(nodeId: Int): $payloadClass?
    }
    """
        .trimIndent()

fun allPayloadDaos(payloadClasses: List<String>) =
    payloadClasses.filter { it != "Node" }.joinToString("\n\n") { payloadDao(it) }

fun database(
    databaseVersion: String,
    payloadClasses: List<String>,
    nodeKindToPayloadClassMap: Map<String, String>,
) =
    """
    @Suppress("UNCHECKED_CAST")
    @Database(entities = [${payloadClasses.joinToString(", ") { "$it::class" }}], version = $databaseVersion)
    abstract class AppDatabase : RoomDatabase() {
        ${payloadClasses.joinToString("\n\n${indent(2)}") { "abstract fun ${daoCall(it)}: ${it}Dao" }}
        
${listOf("insert", "update", "delete").joinToString("\n\n") { bothWriteFunctions(it, payloadClasses) }}

        suspend fun getPayloadByNodeId(nodeKind: NodeKind, nodeId: Int): Payload? =
            when (nodeKind) {
${nodeKindToPayloadClassMap.map { "${indent(4)}NodeKind.${it.key} -> ${daoCall(it.value)}.getPayloadByNodeId(nodeId)" }.joinToString("\n")}
                else -> throw Exception("Invalid entity type")
            }
    }
    """
        .trimIndent()

fun writeFunction(types: List<String>, name: String, many: Boolean) =
    """
    suspend fun $name(${if (many) "entities: List<Any>" else "entity: Any"}) {
        when (${if (many) "entities[0]" else "entity"}) {
            ${types.joinToString("\n${indent(3)}") { "is $it -> ${daoCall(it)}.$name(${if (many) "entities as List<$it>" else "entity"})" }}
            else -> throw Exception("Invalid entity type")
        }
    }
    """
        .replaceIndent(indent(2))

fun bothWriteFunctions(name: String, types: List<String>) =
    writeFunction(types, name, false) + "\n\n" + writeFunction(types, "${name}Many", true)

fun readFunction(name: String, nodeKindToPayloadClassMap: Map<String, String>) =
    """
    suspend fun $name(nodeKind: NodeKind, nodeId: Int): Payload? {
        when (nodeKind) {
            ${nodeKindToPayloadClassMap.map { "${it.key} -> ${daoCall(it.value)}.$name(nodeId)" }.joinToString("\n")}
            else -> throw Exception("Invalid entity type")
        }
    }
    """
        .replaceIndent(indent(2))

fun indent(n: Int) = "    ".repeat(n)

fun camelCase(s: String) = s[0].lowercase() + s.substring(1)

fun daoCall(className: String) = "${camelCase(className)}Dao()"
