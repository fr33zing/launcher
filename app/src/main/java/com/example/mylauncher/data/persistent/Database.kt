// This file is automatically generated, don't edit it!
// Generated by: buildSrc/build.gradle.kts
//
// The generator file must be updated in the following circumstances:
// - Project details (module name, domain, etc) change.
// - NodeKind or payload paths or class names change.
// - New NodeKind variants are added.
// - New payload classes are added.

package com.example.mylauncher.data.persistent

import androidx.room.Dao
import androidx.room.Database
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.Query
import androidx.room.RoomDatabase
import androidx.room.Transaction
import androidx.room.Update
import com.example.mylauncher.data.NodeKind
import com.example.mylauncher.data.persistent.payloads.Application
import com.example.mylauncher.data.persistent.payloads.Payload

@Suppress("UNCHECKED_CAST")
@Database(entities = [Node::class, Application::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun nodeDao(): NodeDao

    abstract fun applicationDao(): ApplicationDao

    suspend fun insert(entity: Any) {
        when (entity) {
            is Node -> nodeDao().insert(entity)
            is Application -> applicationDao().insert(entity)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun insertMany(entities: List<Any>) {
        when (entities[0]) {
            is Node -> nodeDao().insertMany(entities as List<Node>)
            is Application -> applicationDao().insertMany(entities as List<Application>)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun update(entity: Any) {
        when (entity) {
            is Node -> nodeDao().update(entity)
            is Application -> applicationDao().update(entity)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun updateMany(entities: List<Any>) {
        when (entities[0]) {
            is Node -> nodeDao().updateMany(entities as List<Node>)
            is Application -> applicationDao().updateMany(entities as List<Application>)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun delete(entity: Any) {
        when (entity) {
            is Node -> nodeDao().delete(entity)
            is Application -> applicationDao().delete(entity)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun deleteMany(entities: List<Any>) {
        when (entities[0]) {
            is Node -> nodeDao().deleteMany(entities as List<Node>)
            is Application -> applicationDao().deleteMany(entities as List<Application>)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun getPayloadByNodeId(nodeKind: NodeKind, nodeId: Int): Payload? =
        when (nodeKind) {
            NodeKind.Application -> applicationDao().getPayloadByNodeId(nodeId)
            else -> throw Exception("Invalid entity type")
        }
}

@Dao
interface ApplicationDao {
    @Insert suspend fun insert(entity: Application)

    @Transaction @Insert suspend fun insertMany(entities: List<Application>)

    @Update suspend fun update(entity: Application)

    @Transaction @Update suspend fun updateMany(entities: List<Application>)

    @Delete suspend fun delete(entity: Application)

    @Transaction @Delete suspend fun deleteMany(entities: List<Application>)

    @Query("SELECT * FROM Application") suspend fun getAllPayloads(): List<Application>

    @Query("SELECT * FROM Application WHERE nodeId = :nodeId")
    suspend fun getPayloadByNodeId(nodeId: Int): Application?
}
