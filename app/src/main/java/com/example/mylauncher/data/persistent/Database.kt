// This file is automatically generated, don't edit it!
// Generated by: buildSrc/build.gradle.kts
//
// The generator file must be updated in the following circumstances:
// - Project details (module name, domain, etc) change.
// - NodeKind or payload paths or class names change.
// - New NodeKind variants are added.
// - New payload classes are added.

package com.example.mylauncher.data.persistent

import androidx.room.Dao
import androidx.room.Database
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.Query
import androidx.room.RoomDatabase
import androidx.room.Transaction
import androidx.room.Update
import com.example.mylauncher.data.NodeKind
import com.example.mylauncher.data.persistent.payloads.Application
import com.example.mylauncher.data.persistent.payloads.Payload
import kotlin.reflect.KParameter
import kotlin.reflect.typeOf

@Suppress("UNCHECKED_CAST")
@Database(entities = [Node::class, Application::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun nodeDao(): NodeDao

    abstract fun applicationDao(): ApplicationDao

    suspend fun insert(entity: Any) {
        when (entity) {
            is Node -> nodeDao().insert(entity)
            is Application -> applicationDao().insert(entity)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun insertMany(entities: List<Any>) {
        when (entities.firstOrNull() ?: return) {
            is Node -> nodeDao().insertMany(entities as List<Node>)
            is Application -> applicationDao().insertMany(entities as List<Application>)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun update(entity: Any) {
        when (entity) {
            is Node -> nodeDao().update(entity)
            is Application -> applicationDao().update(entity)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun updateMany(entities: List<Any>) {
        when (entities.firstOrNull() ?: return) {
            is Node -> nodeDao().updateMany(entities as List<Node>)
            is Application -> applicationDao().updateMany(entities as List<Application>)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun delete(entity: Any) {
        when (entity) {
            is Node -> nodeDao().delete(entity)
            is Application -> applicationDao().delete(entity)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun deleteMany(entities: List<Any>) {
        when (entities.firstOrNull() ?: return) {
            is Node -> nodeDao().deleteMany(entities as List<Node>)
            is Application -> applicationDao().deleteMany(entities as List<Application>)
            else -> throw Exception("Invalid entity type")
        }
    }

    suspend fun getPayloadByNodeId(nodeKind: NodeKind, nodeId: Int): Payload? =
        when (nodeKind) {
            NodeKind.Application -> applicationDao().getPayloadByNodeId(nodeId)
            else -> throw Exception("Invalid NodeKind")
        }

    fun createDefaultPayloadForNode(nodeKind: NodeKind, nodeId: Int): Payload {
        val payloadClass =
            when (nodeKind) {
                NodeKind.Application -> Application::class
                else -> throw Exception("Invalid NodeKind")
            }
        val constructor =
            payloadClass.constructors.firstOrNull {
                with(it.parameters[0]) { name == "payloadId" && type == typeOf<Int>() } &&
                    with(it.parameters[1]) { name == "nodeId" && type == typeOf<Int>() } &&
                    it.parameters.subList(2, it.parameters.size).all(KParameter::isOptional)
            } ?: throw Exception("No minimal constructor for payload ${payloadClass.simpleName}")
        return with(constructor) { callBy(mapOf(parameters[0] to 0, parameters[1] to nodeId)) }
    }
}

@Dao
interface ApplicationDao {
    @Insert suspend fun insert(entity: Application)

    @Transaction @Insert suspend fun insertMany(entities: List<Application>)

    @Update suspend fun update(entity: Application)

    @Transaction @Update suspend fun updateMany(entities: List<Application>)

    @Delete suspend fun delete(entity: Application)

    @Transaction @Delete suspend fun deleteMany(entities: List<Application>)

    @Query("SELECT * FROM Application") suspend fun getAllPayloads(): List<Application>

    @Query("SELECT * FROM Application WHERE nodeId = :nodeId")
    suspend fun getPayloadByNodeId(nodeId: Int): Application?
}
